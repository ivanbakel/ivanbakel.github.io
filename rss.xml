<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Personal Website</title><link>https://ivanbakel.github.io/</link><description>A portfolio and content website.</description><atom:link href="https://ivanbakel.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2020 &lt;a href="mailto:ivb@vanbakel.io"&gt;Isaac van Bakel&lt;/a&gt; </copyright><lastBuildDate>Tue, 29 Dec 2020 00:22:57 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The Yesod Transformer Library </title><link>https://ivanbakel.github.io/posts/yesod-transformer-library-announced/</link><dc:creator>Isaac van Bakel</dc:creator><description>&lt;div&gt;&lt;h2&gt;The Yesod Transformer Library&lt;/h2&gt;
&lt;p&gt;This post assumes a familiarity with monad transformers.&lt;/p&gt;
&lt;p&gt;As part of my job, I've been spending lots of time in the &lt;a href="https://www.yesodweb.com/"&gt;Yesod&lt;/a&gt; ecosystem - &lt;code&gt;yesod-core&lt;/code&gt; (and &lt;code&gt;yesod-*&lt;/code&gt;), &lt;code&gt;persistent&lt;/code&gt;, and the &lt;code&gt;shakespeare&lt;/code&gt; templating languages. These libraries are particularly easy to contribute back to: the efforts of Michael Snoyman and Matt Parsons, as well as everyone else who puts hard work into those communities, mean that interaction is pleasant, considerate, and meaningful. Their ambitious nature also means that small contributions are relatively easy to make - just fill any utility hole in the vast APIs that already exist.&lt;/p&gt;
&lt;p&gt;However, Yesod's design does come with some pain points. Notably, &lt;code&gt;yesod-core&lt;/code&gt; is in a complicated relationship with &lt;a href="https://hackage.haskell.org/package/mtl"&gt;monad transformers&lt;/a&gt;: it used to support them, and now it doesn't.&lt;/p&gt;
&lt;h3&gt;Monad transformers in Yesod&lt;/h3&gt;
&lt;p&gt;Yesod is based around two monads: &lt;code&gt;HandlerFor site&lt;/code&gt;, which is essentially a request handler for some &lt;em&gt;foundation site&lt;/em&gt; type &lt;code&gt;site&lt;/code&gt;; and &lt;code&gt;WidgetFor site&lt;/code&gt;, which is a specialised handler for building webpages. Specifically, &lt;code&gt;WidgetFor&lt;/code&gt; lets you use do-notation to build a page imperitavely - you can write to the page piece by piece, appending HTML, CSS, and JS directly to the head or body.&lt;/p&gt;
&lt;p&gt;Yesod &lt;em&gt;also&lt;/em&gt; has two monad classes: &lt;code&gt;MonadHandler&lt;/code&gt;, which can be implemented by any monad that can run a &lt;code&gt;HandlerFor&lt;/code&gt;; and &lt;code&gt;MonadWidget&lt;/code&gt;, which has the same property for &lt;code&gt;WidgetFor&lt;/code&gt;. Each base monad type implements its respective monad class. But these classes also have lifting instance for loads of monad transformers. For example, if &lt;code&gt;MonadHandler m&lt;/code&gt;, then &lt;code&gt;MonadHandler (ReaderT r m)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yesodweb/yesod/commit/47ee7384ea123135d090c4e931657cb11c583b94"&gt;&lt;code&gt;HandlerFor&lt;/code&gt; and &lt;code&gt;WidgetFor&lt;/code&gt; used to be transformers&lt;/a&gt;. &lt;code&gt;yesod-core&lt;/code&gt; still contains some references to &lt;code&gt;WidgetT&lt;/code&gt; and &lt;code&gt;HandlerT&lt;/code&gt;, even in non-deprecated APIs. But some years ago, they were changed to be just monads, and the result is an interesting limbo - some code cares about &lt;code&gt;mtl&lt;/code&gt;-style &lt;code&gt;MonadWidget&lt;/code&gt;s and &lt;code&gt;MonadHandler&lt;/code&gt;s, and other code just uses the base monad.&lt;/p&gt;
&lt;p&gt;This change wasn't baseless - Snoyman has written in the past about how overused he thinks full-application monad stacks are, and the value of the &lt;a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/"&gt;"ReaderT" pattern&lt;/a&gt;, where monad state is limited to a reader type and (typically) the &lt;code&gt;IO&lt;/code&gt; monad. In fact, &lt;code&gt;HandlerFor&lt;/code&gt; and &lt;code&gt;WidgetFor&lt;/code&gt; are exactly that - &lt;code&gt;IO&lt;/code&gt; monads which can read the foundation site.&lt;/p&gt;
&lt;h4&gt;What's so bad about that?&lt;/h4&gt;
&lt;p&gt;For the most part, nothing. Concrete types can even add value themselves - error messages from an unexpected type are often much more readable than instance resolution failures in &lt;code&gt;mtl&lt;/code&gt;-style code.&lt;/p&gt;
&lt;p&gt;But the pain points I encountered came from two particular places where &lt;code&gt;yesod-core&lt;/code&gt; interacted with code for my application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;when running the website, and&lt;/li&gt;
&lt;li&gt;when trying to make a custom widget&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Running the website&lt;/h5&gt;
&lt;p&gt;Yesod's design is very tied to the idea of a foundation site - as can be best seen in &lt;a href="https://hackage.haskell.org/package/yesod-core-1.6.18.8/docs/Yesod-Core.html#t:Yesod"&gt;the &lt;code&gt;Yesod&lt;/code&gt; class&lt;/a&gt;. &lt;code&gt;Yesod&lt;/code&gt; is implemented for foundation site types - it describes how the corresponding site performs certain actions. For an example, take the &lt;code&gt;errorHandler&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;errorHandler&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ErrorResponse&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HandlerFor&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="kt"&gt;TypedContent&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;errorHandler&lt;/code&gt; defines how the server takes some kind of error and returns it to the client as content. Crucially, that response &lt;em&gt;must&lt;/em&gt; be a &lt;code&gt;HandlerFor&lt;/code&gt; - it cannot be a generalized &lt;code&gt;MonadHandler&lt;/code&gt;, and it must be runnable (presumably because, otherwise Yesod could not run it). Similar constraints, using &lt;code&gt;WidgetFor&lt;/code&gt; and &lt;code&gt;HandlerFor&lt;/code&gt;, pepper the whole class.&lt;/p&gt;
&lt;p&gt;These choices are not a consequence of the dropping of support for monad transformers - the same design existed well before then. But they do have the same consequences - that &lt;code&gt;site&lt;/code&gt; must do everything. In the above example, there is the constraint (from the type) that the &lt;code&gt;site&lt;/code&gt;, as well as some internal Yesod &lt;code&gt;HandlerData&lt;/code&gt;, must be enough to decide how to give an error response. You cannot return a &lt;code&gt;ReaderT r (... TypedContent)&lt;/code&gt;, even if you need some additional context &lt;code&gt;r&lt;/code&gt; not found in the &lt;code&gt;site&lt;/code&gt;. Similarly, you cannot use a &lt;code&gt;WriterT w (... TypedContent)&lt;/code&gt; to track some error metrics &lt;code&gt;w&lt;/code&gt;, without having to store them in the &lt;code&gt;site&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is not an obstacle most of the time - after all, it's easy to put stuff in the site. But I was interested in making a handler that would change the output of logging on my website, without needing to change all of my code. In &lt;code&gt;mtl&lt;/code&gt; style, this would have been a monad transformer, to modify the monad stack for my handlers. In Yesod, that change isn't so easy.&lt;/p&gt;
&lt;h5&gt;Making custom widgets&lt;/h5&gt;
&lt;p&gt;Widgets, like handlers, are required to be &lt;code&gt;WidgetFor&lt;/code&gt;s at the boundary where your application code touches Yesod's. This is more sensible - rarely do you want hidden outside context on all your widgets. But that doesn't preclude transformers appearing &lt;em&gt;inside&lt;/em&gt; some widget code: like running widgets which all need the same DB data in the same &lt;code&gt;ReaderT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For a more concrete example, consider a problem I had last week: when visualising some submitted data to the user who submitted it, some of it would be obviously erroneous - data could be missing, values would be zero where non-zero was expected, etc. The goal was to let the user know that these anomalies existed in a little report table, &lt;em&gt;and&lt;/em&gt; have that table link to each anomaly in the view.&lt;/p&gt;
&lt;p&gt;The code could have been ugly, because this is a clear case of mixed responsibilities - I needed to spot and track errors in the model, but report them in a way that's directly woven into the view. But there was a more elegant possibility: the view could report anomalies as they were displayed. Once the view was finished rendering, the anomaly report would already be complete. Since the view itself did the reporting, it could even generate a unique ID per report, and make that ID link to the displayed anomaly - when the report was rendered, each link's target would already be in place on the page.&lt;/p&gt;
&lt;p&gt;The resulting approach called for a custom widget type; one which could display basic widgets (&lt;code&gt;WidgetFor site&lt;/code&gt;, which did not report anomalies) alongside their error-reporting cousins. This custom type was a &lt;code&gt;WriterT&lt;/code&gt; transformer on &lt;code&gt;WidgetFor&lt;/code&gt; - and the writer type was the anomaly report itself.&lt;/p&gt;
&lt;p&gt;But this transformer, too, ran into problems. Yesod's &lt;code&gt;whamlet&lt;/code&gt; quasiquoter lets you include HTML snippets as widgets in your Haskell code - and those snippets can themselves embed other widgets. For example, the snippet:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;whamlet&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="kt"&gt;A&lt;/span&gt; &lt;span class="n"&gt;foreboding&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
    &lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;anInnerWidget&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;defines a widget whose layout is the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; header, followed by the layout of the &lt;code&gt;anInnerWidget&lt;/code&gt; widget. What's the type of &lt;code&gt;anInnerWidget&lt;/code&gt;? Yesod requires that it is &lt;code&gt;WidgetFor&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt; the outer widget type is not! In other words, custom widgets cannot use this syntax to nest each other, even though Yesod's &lt;code&gt;WidgetFor&lt;/code&gt;s can.&lt;/p&gt;
&lt;h3&gt;Custom foundation sites&lt;/h3&gt;
&lt;p&gt;Of course, Yesod still affords you plenty of control over how your handlers and widgets will run. Specifically, to allow for configuration options, DB connections, and other runtime values that would be relevant to handlers and widgets, Yesod allows your foundation site to be absolutely anything: the only thing it has to do is implement the relevant classes, like &lt;code&gt;Yesod&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This flexibility on the foundation site type is much more like the polymorphism that &lt;code&gt;mtl&lt;/code&gt; was written to take advantage of. And since Yesod code often restricts us to using &lt;code&gt;HandlerFor site&lt;/code&gt; and &lt;code&gt;WidgetFor site&lt;/code&gt;, there's a neat alternative to monad transformers for Yesod - &lt;strong&gt;site transformers&lt;/strong&gt;.&lt;/p&gt;
&lt;h4&gt;Site transformers&lt;/h4&gt;
&lt;p&gt;A site transformer is largely what it sounds like - a wrapper for a &lt;code&gt;site&lt;/code&gt; type which, like a monad transformer augments a monad, augments the underlying &lt;code&gt;site&lt;/code&gt;. The transformed type still needs to implement relevant classes, like &lt;code&gt;Yesod&lt;/code&gt; - but it is free to do those by delegating to the base class, or defining its own behaviour, as it wants.&lt;/p&gt;
&lt;p&gt;The power of site transformers is: while your handlers and widgets are required to depend only on your &lt;code&gt;site&lt;/code&gt; type, and no additional context, they can depend on the site type &lt;em&gt;as much as they want&lt;/em&gt;. Morever, because access to the Yesod internals lets you change the site type for just a snippet of a handler, that snippet can depend on a different site type to the rest of the code. When running any snippet, you then only have to provide the additional context to use the modified site type.&lt;/p&gt;
&lt;p&gt;To talk about this in more concrete terms, consider this example:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;ReaderSite&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ReaderSite&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;This &lt;code&gt;ReaderSite&lt;/code&gt; is a site transformation that adds additional reader context to handlers and widgets. It doesn't look exactly like a &lt;code&gt;ReaderT&lt;/code&gt;, because the &lt;code&gt;site&lt;/code&gt; itself is already part of a reader (remember, handlers are "Reader IO"s). Any handler with site type &lt;code&gt;ReaderSite r site&lt;/code&gt; can read the transformed site type - so it can access the value with type &lt;code&gt;r&lt;/code&gt;. This means that, by transforming a &lt;code&gt;site&lt;/code&gt; to a &lt;code&gt;ReaderSite r site&lt;/code&gt;, we can &lt;em&gt;add reader context&lt;/em&gt; to a handler - without needing &lt;code&gt;ReaderT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, we can define:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HandlerFor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderSite&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;which readas the reader context from the site. To &lt;em&gt;run&lt;/em&gt; a &lt;code&gt;ReaderSite&lt;/code&gt;, we have to supply the reader context - just like for &lt;code&gt;ReaderT&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;runReaderSite&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HandlerFor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderSite&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HandlerFor&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;In fact, this concept goes all the way to essentially reproducing an &lt;code&gt;mtl&lt;/code&gt;-style design in Yesod - by defining, using, and running site transformers, it's possible to do many of the things &lt;code&gt;mtl&lt;/code&gt; would otherwise let you do: read additional data, write to additional outputs, run parts of your monad code with a modified state, etc. All the while, your code remains compatible with &lt;code&gt;Yesod&lt;/code&gt; itself, because the foundation site type is yours to play with.&lt;/p&gt;
&lt;h3&gt;Announcing YTL&lt;/h3&gt;
&lt;p&gt;That gets me to my main point: based on the above concepts, I've written a new utility library for writing Yesod code: &lt;a href="https://github.com/ivanbakel/ytl"&gt;&lt;code&gt;ytl&lt;/code&gt;, the Yesod Transformer Library&lt;/a&gt;. Like &lt;code&gt;mtl&lt;/code&gt; for monads, &lt;code&gt;ytl&lt;/code&gt; describes site transformers: how to define them;  how to lift handlers and widgets to transformed variants; and how to run transformed handlers and widgets with the underlying site.&lt;/p&gt;
&lt;p&gt;The library itself is already being put into use for &lt;a href="https://github.com/ivanbakel/yesod-katip"&gt;&lt;code&gt;yesod-katip&lt;/code&gt;, a logging bridge I wrote between Yesod webservers and Katip scribes&lt;/a&gt;. But the power of the library is in its extensibility - it provides the tools to define new transformers easily, and integrate them into existing code automatically. Hopefully, others will find that &lt;code&gt;ytl&lt;/code&gt; is just what they've been looking for.&lt;/p&gt;&lt;/div&gt;</description><guid>https://ivanbakel.github.io/posts/yesod-transformer-library-announced/</guid><pubDate>Mon, 28 Dec 2020 18:01:36 GMT</pubDate></item><item><title>Theorem proving in Haskell</title><link>https://ivanbakel.github.io/posts/theorem-proving-in-haskell/</link><dc:creator>Isaac van Bakel</dc:creator><description>&lt;div&gt;&lt;h2&gt;Theorem proving in Haskell&lt;/h2&gt;
&lt;p&gt;This article follows on from &lt;a href="https://ivanbakel.github.io/posts/intuitionistic-logic-in-haskell/"&gt;the previous one&lt;/a&gt; on intuitionistic logic in Haskell. Unlike that one, this is not cover any theory - instead, it's a technical exploration of a Haskell library that simulates a theorem prover.&lt;/p&gt;
&lt;h3&gt;Theorem provers&lt;/h3&gt;
&lt;p&gt;Since Haskell terms are proofs, we can try to use the Haskell compiler as a &lt;strong&gt;theorem prover&lt;/strong&gt; - a program that allows the user to describe a proof as a series of steps, and then checks that the proof is correct. In Haskell's case, we describe proofs as terms, and know they are correct when the term compiles and has the expected type (the statement we are trying to prove).&lt;/p&gt;
&lt;h4&gt;Coq&lt;/h4&gt;
&lt;p&gt;This approach is one taken by many theorem provers: &lt;a href="https://coq.inria.fr/"&gt;Coq&lt;/a&gt; is a theorem prover with an associated dependently-typed language. Coq's type system is powerful enough to encode much more than just the propositional logic we've seen so far: it can be used to make statements about the behaviour of functions, the existence of certain kinds of values, and even other (quantified) statements.&lt;/p&gt;
&lt;p&gt;The Coq compiler is similarly powerful: it is able to enforce that functions are &lt;em&gt;strictly positive&lt;/em&gt; - the property that gave us terminating Haskell terms - while still allowing for a wide range of expressible terms. The power of Coq is such that you can use it to describe and prove complex statements and theorems: but its basic concepts are very similar to the ones we've seen already. Coq proofs are just code; implication terms are just functions.&lt;/p&gt;
&lt;h4&gt;Interactive theorem proving&lt;/h4&gt;
&lt;p&gt;Coq is designed around &lt;em&gt;interactive theorem proving&lt;/em&gt; - proofs can be described as a series of steps, and an editor can step through a proof to see the effect of each step in arriving at the final result. Each step can modify the &lt;strong&gt;environment&lt;/strong&gt; - the set of variables and facts known to the compiler - and the &lt;strong&gt;goals&lt;/strong&gt; - the set of statements which need to be proven. For example, the type &lt;code&gt;forall A B : Prop, A -&amp;gt; B -&amp;gt; A /\ B&lt;/code&gt; says that, from the hypotheses &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, it is possible prove &lt;code&gt;A /\ B&lt;/code&gt; (this is equivalent to the Haskell type &lt;code&gt;a -&amp;gt; b -&amp;gt; a /\ b&lt;/code&gt;). A proof of that statement might look like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kn"&gt;Proof&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;            &lt;span class="c"&gt;(* env: {},                              goals: { forall A B, A -&amp;gt; B -&amp;gt; A /\ B } *)&lt;/span&gt;
  &lt;span class="k"&gt;intros&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="c"&gt;(* env: { A, B : Prop ; a : A ; b : B }, goals: { A /\ B } *)&lt;/span&gt;
  &lt;span class="k"&gt;split&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;          &lt;span class="c"&gt;(* env: { A, B : Prop ; a : A ; b : B }, goals: { A ; B } *)&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="kp"&gt;exact&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;      &lt;span class="c"&gt;(* env: { A, B : Prop ; a : A ; b : B }, goals: { B } *)&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="kp"&gt;exact&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;      &lt;span class="c"&gt;(* env: { A, B : Prop ; a : A ; b : B }, goals: {} *)&lt;/span&gt;
  &lt;span class="kn"&gt;Qed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;At the start of the proof, the environment is empty and there is one goal - the whole statement. The first step, &lt;code&gt;intros&lt;/code&gt;, introduces names into the environment: &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, for the types, and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; for the proofs - and changes the goal to &lt;code&gt;A /\ B&lt;/code&gt;. The second step &lt;code&gt;split&lt;/code&gt;s one goal into two - &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. The third and fourth steps each prove a single goal by providing a term which is &lt;code&gt;exact&lt;/code&gt;ly its proof.&lt;/p&gt;
&lt;p&gt;Coq also allows for such terms to be expressed as functions directly: and vice versa. There's no distinction between what's expressible in the "code style" or the "proof style" of Coq terms.&lt;/p&gt;
&lt;h3&gt;Proof style with monads&lt;/h3&gt;
&lt;p&gt;Looking at the proof style available in Coq and other provers, one immediate candidate for a Haskell implementation springs to mind: do-notation. Haskell's do-notation already gives syntactic support for sequences of steps and name-binding, through &lt;code&gt;x &amp;lt;- ...&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In order to leverage do-notation, we then have to find an appropriate Haskell type which supports it (or otherwise implement one ourselves). While a &lt;code&gt;Monad&lt;/code&gt; instance would be the most obvious choice, it wouldn't be powerful enough; in order to support a changing goal, something about the &lt;code&gt;Monad&lt;/code&gt; type must change over time. We also want to have type-level &lt;em&gt;restrictions&lt;/em&gt;: the &lt;code&gt;split&lt;/code&gt; step, which turns a &lt;code&gt;A /\ B&lt;/code&gt; goal into two subgoals, shouldn't be usable on a goal which isn't an &lt;code&gt;/\&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;An indexed monad&lt;/h4&gt;
&lt;p&gt;It turns out that we can overcome these problems by adding some &lt;em&gt;type-level state&lt;/em&gt; to our monad. The result is called an &lt;a href="https://hackage.haskell.org/package/indexed"&gt;&lt;strong&gt;indexed monad&lt;/strong&gt;&lt;/a&gt;, which (along with definitions for indexed functors and applicatives), has the declaration:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IxApplicative&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IxMonad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;ibind&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;An &lt;code&gt;IxMonad&lt;/code&gt; instance is a type constructor with 3 arguments: the old typestate, the new typestate, and the monad argument. When sequencing indexed monad values, the typestates must "align": the new typestate of the first value must be the old typestate of the second. This is easier to see in the &lt;code&gt;IxApplicative&lt;/code&gt; definition (slightly modified here for readability):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IxFunctor&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IxApplicative&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;ipure&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;iap&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;iap&lt;/code&gt;, as well as applying the function type, also "composes" the typestates: the resulting monad value has the old typestate of the first argument, and the new typestate of the second.&lt;/p&gt;
&lt;h4&gt;The goal as typestate&lt;/h4&gt;
&lt;p&gt;So we might want an indexed monad; but what should its typestate be? The type-level information we care about are the environment and the goal. However, the environment (a collection of variables and definitions) is already handled by Haskell as a programming language: do-notation even has a way to bind variables, with the arrow &lt;code&gt;&amp;lt;-&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It follows that the typestate of our indexed monad turns out to be the &lt;em&gt;goal&lt;/em&gt;. Proof steps, as monad values, are really then &lt;em&gt;goal transformations&lt;/em&gt;. Such a monad value is itself a proof that, in a certain environment, some goal transformation is valid: a proof step that goes from a goal of &lt;code&gt;a&lt;/code&gt; to a goal of &lt;code&gt;b&lt;/code&gt; must also prove that from a proof of &lt;code&gt;b&lt;/code&gt; it's possible to get a proof of &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;The &lt;code&gt;Tactic&lt;/code&gt; monad&lt;/h4&gt;
&lt;p&gt;How then do we actually define the monad? We can do that by thinking about what valid goal transformations we will want to have.&lt;/p&gt;
&lt;p&gt;If a monad value has some final type variable &lt;code&gt;a&lt;/code&gt;, then it will be possible to bind that value to a variable which then has type &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;myTransformation&lt;/span&gt; &lt;span class="c1"&gt;-- myTransformation has type m i j a&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;                   &lt;span class="c1"&gt;-- from here on, x has type a&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The remaining proof with goal &lt;code&gt;j&lt;/code&gt; will have access to a proof of &lt;code&gt;a&lt;/code&gt; through the variable &lt;code&gt;x&lt;/code&gt;. Such a goal transformation &lt;em&gt;introduces&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; as a hypothesis for the rest of the proof; if the goal from that point on is &lt;code&gt;j&lt;/code&gt;, then the proof shows that &lt;code&gt;a -&amp;gt; j&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But the original goal was &lt;code&gt;i&lt;/code&gt;, not &lt;code&gt;j&lt;/code&gt; - so the goal transformation has to justify why a proof of &lt;code&gt;a -&amp;gt; j&lt;/code&gt; gives a proof of &lt;code&gt;i&lt;/code&gt;. In other words, the goal transformation is an inhabitant of &lt;code&gt;(a -&amp;gt; j) -&amp;gt; i&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This gives our monad definition:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The name &lt;code&gt;Tactic&lt;/code&gt; comes from the term used for such proof steps in many theorem provers.&lt;/p&gt;
&lt;h4&gt;Some tactics&lt;/h4&gt;
&lt;p&gt;Now that we know the shape of the monad, it's very easy to start writing tactic instances like the ones we would expect to see in any theorem prover (if you're not interested in examples, skip this section).&lt;/p&gt;
&lt;p&gt;Coq's &lt;code&gt;intro&lt;/code&gt;, for example, allows you to give a name to the left side of an &lt;code&gt;-&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;intro&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Such a goal transformation requires an inhabitant for &lt;code&gt;(a -&amp;gt; b) -&amp;gt; (a -&amp;gt; b)&lt;/code&gt; - so the definition is pretty obvious:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;intro&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;left&lt;/code&gt; tactic simplifies proving an &lt;code&gt;\/&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;left&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;This tactic doesn't introduce any hypothesis - and that won't be a problem later, since we can always construct a value of type &lt;code&gt;()&lt;/code&gt; when necessary.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;left&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;Canonical truth&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;Tactic&lt;/code&gt; monad (once you define the necessary typeclass instances) lets you do proof steps with do notation: but we still can't describe a whole proof. Specifically, we don't know when we are "done" proving a statement - after all, we could always apply further goal transformations.&lt;/p&gt;
&lt;p&gt;We could be satisfied by reducing the proof of a statement to the proof of some other statement which we've already proved i.e. producing a term of type &lt;code&gt;Tactic a b ()&lt;/code&gt;, where we know &lt;code&gt;b&lt;/code&gt; and want to prove &lt;code&gt;a&lt;/code&gt;. Such a proof would inhabit &lt;code&gt;(() -&amp;gt; b) -&amp;gt; a)&lt;/code&gt; - and since &lt;code&gt;() -&amp;gt; b&lt;/code&gt; is inhabited (since we know &lt;code&gt;b&lt;/code&gt; to be true), then we can get an inhabitant for &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In practice, however, it's useful to have a &lt;em&gt;single&lt;/em&gt; choice for such a known statement - and that statement represents "truth" in the type system. Additionally, it would be nice for this choice of truth to have a single, &lt;strong&gt;canonical&lt;/strong&gt; constructor - so that all proofs of truth are the same. Together, these justify choosing &lt;code&gt;()&lt;/code&gt; as the representation of truth.&lt;/p&gt;
&lt;h4&gt;Even more tactics&lt;/h4&gt;
&lt;p&gt;Using this representation of truth, we can describe tactics that &lt;em&gt;solve&lt;/em&gt; goals - that is, transform goals into the goal of &lt;code&gt;()&lt;/code&gt;. (Again, if you don't want examples, skip this section.)&lt;/p&gt;
&lt;p&gt;Coq's &lt;code&gt;exact&lt;/code&gt; tactic solves a goal by giving a term of the exact type of the goal:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;exact&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;exact&lt;/span&gt; &lt;span class="n"&gt;proof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;proof&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;split&lt;/code&gt; tactic in Coq turns a goal of &lt;code&gt;A /\ B&lt;/code&gt; into two subgoals of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. However, the &lt;code&gt;Tactic&lt;/code&gt; monad doesn't support multiple goals: so how can we represent it? The answer is through &lt;em&gt;subproofs&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;split&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;/\&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;These subproofs require solving their respective subgoals. The tactic then allows you to solve a goal of &lt;code&gt;a /\ b&lt;/code&gt; by providing a proof for each of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The resulting proofs can finally be combined:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;split&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;getA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;getB&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;trivial&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getA&lt;/span&gt; &lt;span class="n"&gt;trivial&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getB&lt;/span&gt; &lt;span class="n"&gt;trivial&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;This technique of subproofs allows for defining lots of other useful tactics. The &lt;code&gt;assert&lt;/code&gt; tactic in Coq allows for stating a subgoal, proving it, and giving the resulting proof a name to use later.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;assert&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt; takes the proof of the subgoal, and allows it to be bound in do-notation. Using the bound variable later on just uses the subproof.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;getSubproof&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;getSubproof&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;A complete proof&lt;/h3&gt;
&lt;p&gt;We can then define a complete proof as one which solves its goal:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Proof&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Proof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Of course, such a definition is justified only if we can use it to get an inhabitant of &lt;code&gt;a&lt;/code&gt;. In fact, this defines a complete proof as inhabitant of &lt;code&gt;(() -&amp;gt; ()) -&amp;gt; a&lt;/code&gt;, which can very easily be used to obtain an inhabitant of &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;useProof&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Proof&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;useProof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Proof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tactic&lt;/span&gt; &lt;span class="n"&gt;transformation&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transformation&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><guid>https://ivanbakel.github.io/posts/theorem-proving-in-haskell/</guid><pubDate>Sun, 20 Sep 2020 11:35:13 GMT</pubDate></item><item><title>Intuitionistic logic in Haskell</title><link>https://ivanbakel.github.io/posts/intuitionistic-logic-in-haskell/</link><dc:creator>Isaac van Bakel</dc:creator><description>&lt;div&gt;&lt;h2&gt;Intuitionistic logic in Haskell&lt;/h2&gt;
&lt;p&gt;This article assumes a familiarity with Haskell, and some basic knowledge of classical logic (if you don't know about different varieties of logic, the one you &lt;em&gt;do&lt;/em&gt; know is probably classical).&lt;/p&gt;
&lt;h3&gt;Terminating Haskell&lt;/h3&gt;
&lt;h4&gt;The &lt;code&gt;Void&lt;/code&gt; datatype&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;Void&lt;/code&gt; datatype is part of the Haskell standard library, and should be well-known by most Haskellers. In short, &lt;code&gt;Void&lt;/code&gt; has the following declaration&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;That is: it's a datatype, with an empty collection of constructors (you may be surprised this is a valid declaration). The consequence is that it's impossible to construct any value with type &lt;code&gt;Void&lt;/code&gt;, a fact that both programmers and the compiler can exploit.&lt;/p&gt;
&lt;p&gt;Though a &lt;code&gt;Void&lt;/code&gt; value is &lt;em&gt;unconstructable&lt;/em&gt;, it is still very simple to write a valid Haskell term which has the &lt;code&gt;Void&lt;/code&gt; type.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;aVoidTerm&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt;
&lt;span class="nf"&gt;aVoidTerm&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aVoidTerm&lt;/span&gt;

&lt;span class="c1"&gt;-- Alternatively:&lt;/span&gt;
&lt;span class="nf"&gt;aVoidTerm&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;undefined&lt;/span&gt;
&lt;span class="c1"&gt;-- Or even:&lt;/span&gt;
&lt;span class="nf"&gt;aVoidTerm&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"Tried to evaluate a `Void` term"&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;These terms all share the property of being &lt;strong&gt;non-terminating&lt;/strong&gt;. While lazy evaluation lets them appear in programs without any problem, any attempt to evaluate these terms will fail: either because of an infinite loop or a runtime error.&lt;/p&gt;
&lt;h4&gt;Terminating terms&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Terminating&lt;/strong&gt; terms are the subset of all Haskell terms which can be evaluated in finite time without error. While it's impossible to decide in general if a particular term is terminating, we can restrict our language so that we can &lt;em&gt;only&lt;/em&gt; write terminating terms. One way to do that is to require that recursive functions are &lt;strong&gt;strictly positive&lt;/strong&gt; - so all recursive calls are with arguments that are "smaller" than the current argument - and &lt;strong&gt;total&lt;/strong&gt; - defined for every possible argument.&lt;/p&gt;
&lt;p&gt;If we implement those two restrictions in Haskell, we get a subset of the language that can only express terminating Haskell terms - though it can't express every terminating Haskell term. In terminating Haskell, we can &lt;em&gt;no longer&lt;/em&gt; write terms with a &lt;code&gt;Void&lt;/code&gt; type: there's no way to define such a term recursively, because it won't get "smaller"; and there's no way to leave the value &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you can force the evaluation of a &lt;code&gt;Void&lt;/code&gt; term, you can't get some terminating value, so there is no well-defined "after" evaluation. The compiler even lets you exploit this fact to write a terminating term that evaluates a &lt;code&gt;Void&lt;/code&gt; value, and then returns a value of &lt;em&gt;any type&lt;/em&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="cm"&gt;{-# LANGUAGE EmptyCase #-}&lt;/span&gt;
&lt;span class="nf"&gt;useAVoid&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;useAVoid&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;This code uses the &lt;code&gt;EmptyCase&lt;/code&gt; language extension to allow us to write a &lt;code&gt;case&lt;/code&gt; statement with no branches - remembering that &lt;code&gt;case&lt;/code&gt; statements have to be total, this means that the above code only compiles because &lt;code&gt;Void&lt;/code&gt; has &lt;em&gt;no cases&lt;/em&gt; to branch on. While the function definition itself is terminating, the result can have type &lt;code&gt;a&lt;/code&gt;, for any choice of &lt;code&gt;a&lt;/code&gt;, because by evaluating the argument it will never terminate and be forced to produce an &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;Inhabited types&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Void&lt;/code&gt; has the property of being &lt;strong&gt;uninhabited&lt;/strong&gt;, because it has no "inhabitants" - valid terminating terms which have the &lt;code&gt;Void&lt;/code&gt; type. Types with inhabitants are, unsurprisingly, said to be &lt;strong&gt;inhabited&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;We have already seen that &lt;code&gt;Void -&amp;gt; a&lt;/code&gt; is inhabited for any choice of &lt;code&gt;a&lt;/code&gt;, even uninhabited choices - in fact, this is only because &lt;code&gt;Void&lt;/code&gt; is uninhabited. For a (terminating) function with type &lt;code&gt;a -&amp;gt; b&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; can be uninhabited only if &lt;code&gt;a&lt;/code&gt; is uninhabited - otherwise the function could evaluate the argument of type &lt;code&gt;a&lt;/code&gt;, have it terminate, and be forced to produce a terminating value of type &lt;code&gt;b&lt;/code&gt;: an impossibility.&lt;/p&gt;
&lt;p&gt;A consequence is that the type &lt;code&gt;a -&amp;gt; Void&lt;/code&gt; is inhabited only for choices of &lt;code&gt;a&lt;/code&gt; which are uninhabited. Moreover, if &lt;code&gt;a&lt;/code&gt; is uninhabited, then we can write a terminating term with type &lt;code&gt;a -&amp;gt; Void&lt;/code&gt; - just like we did for &lt;code&gt;Void -&amp;gt; a&lt;/code&gt; - by exploiting the fact that &lt;code&gt;a&lt;/code&gt; has no inhabitants. The result is: &lt;code&gt;a -&amp;gt; Void&lt;/code&gt; is inhabited if and only if &lt;code&gt;a&lt;/code&gt; is uninhabited, and vice versa.&lt;/p&gt;
&lt;p&gt;We can extend this reasoning about inhabitants to many other basic Haskell types. &lt;code&gt;Maybe a&lt;/code&gt;, for example, is always inhabited by the terminating term &lt;code&gt;Nothing&lt;/code&gt;, even for uninhabited choices of &lt;code&gt;a&lt;/code&gt;. &lt;code&gt;Either a b&lt;/code&gt; is inhabited provided one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is inhabited, because you could wrap the terminating term with type &lt;code&gt;a&lt;/code&gt; (or &lt;code&gt;b&lt;/code&gt;) in a &lt;code&gt;Left&lt;/code&gt; (or &lt;code&gt;Right&lt;/code&gt;) constructor to give a terminating term of type &lt;code&gt;Either a b&lt;/code&gt;. Conversely, if &lt;code&gt;Either a b&lt;/code&gt; is inhabited, then &lt;em&gt;at least one&lt;/em&gt; of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; must be inhabited (though the proof is much more difficult to summarize). In a similar vein, the tuple type &lt;code&gt;(a, b)&lt;/code&gt; is inhabited if and only if &lt;em&gt;both&lt;/em&gt; &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; are inhabited.&lt;/p&gt;
&lt;h3&gt;Types and logic&lt;/h3&gt;
&lt;p&gt;Astute readers may have already spotted the point of the above discussion: this reasoning about inhabited types looks a lot like formal logic.&lt;/p&gt;
&lt;p&gt;If inhabitedness is "truth", then uninhabitedness is "falsehood". Continuing the comparison, &lt;code&gt;a -&amp;gt; Void&lt;/code&gt; is the "negation" of &lt;code&gt;a&lt;/code&gt; - since it is uninhabited if and only if &lt;code&gt;a&lt;/code&gt; is inhabited, and vice versa; &lt;code&gt;Either a b&lt;/code&gt; is the "or" of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, since it is inhabited if and only if at least one of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is'; and &lt;code&gt;(a, b)&lt;/code&gt; is the "and".&lt;/p&gt;
&lt;p&gt;It remains to check that &lt;code&gt;a -&amp;gt; b&lt;/code&gt; follows the expected behaviour of "implies" - that &lt;code&gt;a -&amp;gt; b&lt;/code&gt; is uninhabited (aka false) if and only if &lt;code&gt;a&lt;/code&gt; is inhabited (true) and &lt;code&gt;b&lt;/code&gt; is uninhabited (false). In fact, due to arguments which include the ones made earlier on, we find that this is the case - and that &lt;code&gt;-&amp;gt;&lt;/code&gt;, as well as resembling the "implies" arrow, also seems to act like one.&lt;/p&gt;
&lt;p&gt;The similarities don't stop there. If we introduce some type aliases to make our types easier to read:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="cm"&gt;{-# LANGUAGE TypeOperators #-}&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;/\&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Then we can wonder if some inhabitants exist for certain types which correspond to logical statements we know to be true. One example would be the commutativity of &lt;code&gt;/\&lt;/code&gt; - that &lt;code&gt;a /\ b -&amp;gt; b /\ a&lt;/code&gt;. A programmer could quickly produce such an inhabitant:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;andComm&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;/\&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;/\&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="c1"&gt;-- i.e. :: (a, b) -&amp;gt; (b, a)&lt;/span&gt;
&lt;span class="nf"&gt;andComm&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;We can also wonder if types which corresponding to false logical statements are &lt;em&gt;uninhabited&lt;/em&gt;. For example, &lt;code&gt;a /\ Not a&lt;/code&gt; should never hold, so the type should be uninhabited. It follows that &lt;code&gt;Not (a /\ Not a)&lt;/code&gt; is inhabited: in fact it is.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;explosion&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;/\&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;--   i.e. :: (a, a -&amp;gt; Void) -&amp;gt; Void&lt;/span&gt;
&lt;span class="nf"&gt;explosion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Programmers who struggle with logic may notice that rewriting the type in terms of Haskell types makes for much simpler reading: it's pretty easy to spot that &lt;code&gt;(a, a -&amp;gt; Void) -&amp;gt; Void&lt;/code&gt; is inhabited, and even to immediately write out the above inhabitant.&lt;/p&gt;
&lt;h4&gt;The excluded middle&lt;/h4&gt;
&lt;p&gt;A pretty important rule for classical logic is the "law of the excluded middle" - that every statement is either definitely true, or definitely false. &lt;/p&gt;
&lt;p&gt;We can express this in our types as &lt;code&gt;a \/ Not a&lt;/code&gt;. But can we inhabit it? For particular choices of &lt;code&gt;a&lt;/code&gt;, sure: if we knew that &lt;code&gt;a&lt;/code&gt; was &lt;code&gt;Int&lt;/code&gt;, or &lt;code&gt;Void&lt;/code&gt;, or even &lt;code&gt;Maybe b&lt;/code&gt;, we would be able to produce an inhabitant easily:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;intLOEM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="nf"&gt;intLOEM&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="nf"&gt;voidLOEM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt;
&lt;span class="c1"&gt;--  i.e. :: Either Void (Void -&amp;gt; Void)&lt;/span&gt;
&lt;span class="nf"&gt;voidLOEM&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;

&lt;span class="nf"&gt;maybeLOEM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;maybeLOEM&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;But for a &lt;em&gt;polymorphic&lt;/em&gt; &lt;code&gt;a&lt;/code&gt;, we struggle. While every type in Haskell is definitely inhabited or uninhabited, we can't in general produce an inhabitant of the type, or an inhabitant for the type's "negation", without knowing &lt;em&gt;which&lt;/em&gt; type we're dealing with.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kt"&gt;LOEM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="kt"&gt;LOEM&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt; &lt;span class="c1"&gt;-- uh oh&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Does this mean that our strange similarities are just a coincidence? After all, &lt;code&gt;a \/ Not a&lt;/code&gt; is certainly true - so we expect to be able to produce an inhabitant. Notably, we also fail to "negate" the law of excluded middle - we can't produce an inhabitant for &lt;code&gt;Not (a \/ Not a)&lt;/code&gt; either. In the logic of our types, we don't know if &lt;code&gt;a \/ Not a&lt;/code&gt; is "true" or "false".&lt;/p&gt;
&lt;p&gt;What has actually happened is that we've departed from &lt;em&gt;classical&lt;/em&gt; logic: our types do behave like a logical system, just a different one.&lt;/p&gt;
&lt;h4&gt;What makes classical logic?&lt;/h4&gt;
&lt;p&gt;While most users of logic - particularly mathematicians - take the law of excluded middle as a universal truth, and apply it liberally in proofs, it's not a necessary part of any logical system. Classical logic is actually defined in part by the existence of this law, and double negation: &lt;code&gt;Not (Not a) -&amp;gt; a&lt;/code&gt; (interested readers can &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.6941"&gt;read more about these laws&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Double negation is another statement that doesn't have an inhabitant in Haskell - and nor does its negation. In a logical system without either law, several statements which are true in classical logic also no longer hold: Peirce's law, &lt;code&gt;((a -&amp;gt; b) -&amp;gt; a) -&amp;gt; a&lt;/code&gt;; the double contrapositive, &lt;code&gt;(Not b -&amp;gt; Not a) -&amp;gt; (a -&amp;gt; b)&lt;/code&gt;; the implies equivalence &lt;code&gt;(a -&amp;gt; b) -&amp;gt; (Not a \/ b)&lt;/code&gt;; de Morgan's laws, such as &lt;code&gt;Not (Not a /\ Not b) -&amp;gt; (a \/ b)&lt;/code&gt;; and many more. Similarly, none of these Haskell types have inhabitants.&lt;/p&gt;
&lt;h4&gt;Intuitionistic logic&lt;/h4&gt;
&lt;p&gt;If the logic that we see in Haskell types isn't classical logic, what then is it?&lt;/p&gt;
&lt;p&gt;The feature of Haskell that prevents all these types from having inhabitants is that, in Haskell, we must &lt;em&gt;construct terms explicitly&lt;/em&gt;. In classical logic, the statement &lt;code&gt;a \/ b&lt;/code&gt; holds if and only if at least one of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; holds - but our knowledge of &lt;code&gt;a \/ b&lt;/code&gt; doesn't necessarily tell us which one it is. In Haskell, on the other hand, you can use an &lt;code&gt;Either a b&lt;/code&gt; to get either an &lt;code&gt;a&lt;/code&gt; or a &lt;code&gt;b&lt;/code&gt;, by &lt;em&gt;deconstructing&lt;/em&gt; the term. In other words, Haskell requires that every term of type &lt;code&gt;a \/ b&lt;/code&gt; only be &lt;em&gt;constructed&lt;/em&gt;, from a term with type &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This limitation doesn't just appear in Haskell. In fact, this exact behaviour describes &lt;strong&gt;intuitionistic logic&lt;/strong&gt; - a subset of classical logic. Intuitionistic logic is precisely what you get when you get rid of the laws of the excluded middle and double negation frrom classical logic. The resulting system still makes sense - it's just less powerful. Lots of statements with classical proofs have no equivalent intuitionistic proof.&lt;/p&gt;
&lt;h4&gt;Constructive mathematics and decidability&lt;/h4&gt;
&lt;p&gt;Just like classical logic tries to formalise the reasoning of classical mathematics, intuitionistic logic tries to formalise the reasoning of &lt;strong&gt;constructive mathematics&lt;/strong&gt; (for this reason, it is sometimes called &lt;em&gt;constructive logic&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Godel's successful proof of the first Incompleteness theorem showed that every system of reasoning about numbers included statements that were &lt;strong&gt;undecidable&lt;/strong&gt;. These statements couldn't be proven, and their contradiction couldn't be proven - in other words, it was impossible for &lt;em&gt;some&lt;/em&gt; statement &lt;code&gt;a&lt;/code&gt; to prove either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;Not a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As a result, several mathematicians became dissatisfied with classical logic: a binary idea of truth no longer seemed correct. They devised a new mathematics without the use of the law of excluded middle or double negation in proofs - since a proof of &lt;code&gt;Not (Not a)&lt;/code&gt; only showed that &lt;code&gt;a&lt;/code&gt; wasn't false: not that it was true. This system was termed &lt;strong&gt;constructive mathematics&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In constructive mathematics, as in intuitionistic logic, proofs are only possible by explicit construction. To prove &lt;code&gt;a \/ b&lt;/code&gt;, it is necessary to give a proof of &lt;code&gt;a&lt;/code&gt; or a proof of &lt;code&gt;b&lt;/code&gt; - it's not enough to argue that at least one must be true. This system ends up being weaker - several statements which are provable in classical mathematics are undecidable in constructive mathematics.&lt;/p&gt;
&lt;h4&gt;Decidability as a constraint&lt;/h4&gt;
&lt;p&gt;Returning to Haskell for a moment, we can use this insight to produce a weaker version of the law of the excluded middle, just for &lt;em&gt;decidable&lt;/em&gt; statements. Haskell allows us to express decidability as a constraint on a logical statement (a type), by using a typeclass:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Decidable&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;decide&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="kt"&gt;LOEM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Decidable&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="kt"&gt;LOEM&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;decide&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Restricting ourselves to decidable statements is even enough to re-introduce double negation:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;doubleNegation&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Decidable&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;doubleNegation&lt;/span&gt; &lt;span class="n"&gt;doubleNegative&lt;/span&gt;
  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decide&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;\/&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
      &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
      &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;useAVoid&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;doubleNegative&lt;/span&gt; &lt;span class="n"&gt;notA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;The Curry-Howard isomorphism&lt;/h3&gt;
&lt;p&gt;So Haskell types look like logical statements - and in particular, it looks like statements provable in intuitionistic logic correspond to inhabited Haskell types. But what does that mean for Haskell &lt;em&gt;terms&lt;/em&gt;?&lt;/p&gt;
&lt;h4&gt;Code as proof&lt;/h4&gt;
&lt;p&gt;To the Haskell compiler, a (terminating) term is a demonstration that a particular type is inhabited. In declaring the type signature for a definition, you claim the type is inhabited: in the definition itself, you &lt;em&gt;prove&lt;/em&gt; it. When you consider types as a logic, this analogy makes even more sense: where a type is a logical statement, a term is a proof that the type is inhabited, and so that the statement is true. Proving the negation of a statement is done by showing that the negated type is inhabited.&lt;/p&gt;
&lt;p&gt;This matchup - types as statements, terms as proof - hasn't gone unnoticed among computer scientists: it's been described in &lt;a href="http://www.dcc.fc.up.pt/~acm/howard.pdf"&gt;informal papers&lt;/a&gt; since the 70s. Named the &lt;strong&gt;Curry-Howard Correspondence&lt;/strong&gt; (or isomorphism), it was first spotted in the lambda calculus - the functional abstract computer that Haskell was inspired by.&lt;/p&gt;
&lt;h4&gt;Computing proofs&lt;/h4&gt;
&lt;p&gt;One of the most interesting parts of the CHC comes from considering &lt;code&gt;-&amp;gt;&lt;/code&gt; - both implication and function. The type &lt;code&gt;a -&amp;gt; b&lt;/code&gt; is both the logical statement that &lt;code&gt;a&lt;/code&gt; implies &lt;code&gt;b&lt;/code&gt;, and the type of transformations of values of type &lt;code&gt;a&lt;/code&gt; into values of type &lt;code&gt;b&lt;/code&gt;. But since a value of type &lt;code&gt;a&lt;/code&gt; is a proof for &lt;code&gt;a&lt;/code&gt;, such a transformation also &lt;em&gt;transforms proofs&lt;/em&gt;: given a proof for &lt;code&gt;a&lt;/code&gt;, it yields a proof for &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And since proofs are code, that means that evaluating a proof involving running those proof transformations. A Haskell term like &lt;code&gt;f x&lt;/code&gt; with type &lt;code&gt;b&lt;/code&gt; is made of a proof &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;a -&amp;gt; b&lt;/code&gt;, and a proof &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;a&lt;/code&gt; (for some &lt;code&gt;a&lt;/code&gt;). In &lt;em&gt;running&lt;/em&gt; &lt;code&gt;f x&lt;/code&gt;, we use the proof of &lt;code&gt;a -&amp;gt; b&lt;/code&gt; combined with the proof of &lt;code&gt;a&lt;/code&gt; to get a proof for &lt;code&gt;b&lt;/code&gt;: and the resulting value has the same type. By evaluating a proof, we get a new proof for the same statement. In other words, computation &lt;em&gt;simplifies&lt;/em&gt; proofs.&lt;/p&gt;
&lt;h4&gt;Cut-free proofs&lt;/h4&gt;
&lt;p&gt;But what does this "simplification" actually mean in a proof? How can proofs transform other proofs? The answer comes from considering what our logical types actually mean. &lt;code&gt;a -&amp;gt; b&lt;/code&gt; is a representation of the statement "from the hypothesis a, it is possible to prove b". Inhabitants of &lt;code&gt;a -&amp;gt; b&lt;/code&gt; are proofs which assume that &lt;code&gt;a&lt;/code&gt; is true, and use it to construct a proof of &lt;code&gt;b&lt;/code&gt;. But in order to &lt;em&gt;use&lt;/em&gt; such a proof to prove &lt;code&gt;b&lt;/code&gt;, it is necessary to produce a proof of &lt;code&gt;a&lt;/code&gt;: and the resulting proof has some redundancy. If you can prove &lt;code&gt;a&lt;/code&gt;, there's no need for another proof to &lt;em&gt;assume&lt;/em&gt; that &lt;code&gt;a&lt;/code&gt; is true - it could just use the proof of &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consider the same situation in Haskell. If you apply a function to an argument&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;then computing the function application substitutes the argument value into the function body.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="kr"&gt;in&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;This term could be written both ways: the behaviour is the same. The only difference is that the first version, when computed, turns into the second.&lt;/p&gt;
&lt;p&gt;This construction - proving both an implication and its assumption - is called a &lt;strong&gt;cut&lt;/strong&gt; in a proof. When we evaluate a proof as a Haskell term, we actually &lt;em&gt;eliminate&lt;/em&gt; the cuts in the proof: since a cut is just a function application, and computing function applications is how Haskell code is executed. Since we are limited to terminating terms, executing proofs must eventually give us a simplified proof with &lt;em&gt;no cuts&lt;/em&gt; in it (because it cannot be simplified any more).&lt;/p&gt;
&lt;p&gt;This line of reasoning leads us to a very significant result about intuitionistic (and classical) proofs: the &lt;strong&gt;cut elimination theorem&lt;/strong&gt;. Shown by &lt;a href="https://link.springer.com/article/10.1007/BF01201363"&gt;Gentzen&lt;/a&gt; in 1935, the theorem states that every statement with a proof that contains cuts, also has a proof that contains &lt;em&gt;no&lt;/em&gt; cuts. We have the framework to prove the same result: if every intuitionistic proof corresponds to a terminating Haskell term, where cuts are function application, then computation does the rest of the work. To get a cut-free version of an existing proof, it is sufficient to run the proof fully.&lt;/p&gt;&lt;/div&gt;</description><guid>https://ivanbakel.github.io/posts/intuitionistic-logic-in-haskell/</guid><pubDate>Fri, 18 Sep 2020 23:00:00 GMT</pubDate></item></channel></rss>